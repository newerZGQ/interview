
- 泛型
  - 只在编译阶段有效
  - 无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个 static 的方法而已，无法访问泛型类型的参数。所以如果 static 方法要使用泛型能力，就必须使其成为泛型方法。
  - 泛型做入参时如`void test(GenericHolder holder)`，GenericHolder<Fruit>和 GenericHolder<Apple>是两种不同的类型，所以要有通配符?。? extends T 表示上界，? super T 表示下界
  - 有界的类型参数`class Test<T extends Fruit>`
  - 子类可以指定父类的泛型类型，也可以不指定，不指定的话要按照父类泛型的标志重新声明
  - 类型擦除：Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的 List<Object>和 List<String>等类型，在编译之后都会变成 List。JVM 看到的只是 List。
    - 泛型类并没有独有的 class，比如并不存在 List<String>.class 或是 List<Integer>.class，而只有 List.class。
    - 静态变量是被泛型类的所有实例所共享
    - 泛型的类型参数不能用在 Java 异常处理的 catch 语句中。因为异常处理是由 JVM 在运行时刻来进行的。
    - 编译器承担了全部的类型检查工作