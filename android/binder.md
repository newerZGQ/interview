- binder机制
  - binder机制是android中实现进程间通信的主要手段，区别于linux传统的ipc机制，传统的linux进程间通信走的是两次内存拷贝的方式，及在内核区开辟一块内存，当客户端与服务端交互时，会使用系统调用copy_from_user先将请求的数据从客户端拷贝到内核缓存区，然后服务端接受数据时，先在自己的用户态缓存区开辟一块内存区域，由系统调用copy_to_user将内核缓存区的数据拷贝过去，经历两次内存复制，这样的方式缺陷很明显，一是效率不行，因为两次拷贝，二是需要开辟的内存空间大小不知道，只能尽可能大的开辟。而Android的binder机制采用内存映射机制将两次拷贝将到了一次拷贝，在binder位于的内核中，开辟一块内核缓存A和数据接收缓存区B，当client请求向server传递数据时，会先将数据拷贝到A中，这也是唯一的一次copy，之后的过程，由于A到B，B到server的用户态内存区存在内存映射，所以A中的数据变化会直接反映到server的内存中.
  - 那么在这个过程中，binder起到什么样的作用呢？在binder机制中，涉及到几个模块，client，server，servicemanager，binder。从server说起，service有我们自己开发的service，只要在注册的时候设置成export true就行，应用的service在应用启动的时候注册，也有系统service，比如ActivityManagerService，在系统启动的时候注册，注册的时候，由server创建binder的实例，并将binder的名字以及实体打包通过binder驱动传给servicemanager，这个时候的binder数据已经跨进程了，然后servicemanager根据这些数据注册server，就是记录下，有哪个server对应了哪个binder，同时会在binder驱动的内核区创建这个binder的实体节点并在servicemanager中记录。
  - 那么注册server需要用到binder，使用server也用到binder，到底谁先谁后呢？其实，在系统启动时，就创建了一个binder，这个binder由servicemanager创建，用于注册server，这个binder的实体引用固定为0，任何应用都可直接使用。
  - 之后，client就可以通过0号binder，根据名称，由servicemanager在注册表中查询请求到某个server的binder，就与server建立的连接
  - 使用binder请求数据的过程：将客户端的请求参数通过Parcel包装后传到远程服务端，远程服务端解析数据并执行对应的操作，同时客户端线程挂起，当服务端方法执行完毕后，再将返回结果写入到另外一个Parcel中并将其通过Binder传回到客户端，客户端接收到返回数据的Parcel后，Binder会解析数据包中的内容并将原始结果返回给客户端，至此，整个Binder的工作过程就完成了
  - binder中的代理模式，从aidl的生成类中可以看到，有一个抽象类stub和一个proxy类，stub类继承了IBinder，这个类在创建连接时由service创建，要实现我们自定义的接口，并在server中操作数据。而proxy是给client用的，因为binder虽然实现了我们的接口，但是是由server实现的，就是说他的实现不是给我们client调用使用的。而proxy实现了我们定义的接口，同时使用了binder的trasact方法向server发起请求。所以我们在proxy的实现方法中，一般都是这个流程，首先向系统申请parcel内存空间，这个空间包括两部分，一个是要传给server的，一个是让server写入数据返回的，然后就是写入parcel数据，调用binder的trasact方法，通过binder驱动请求数据。这个代理模式在acitivitymanagerservice中也有体现，代理执行的是一个ActivitymanagerNative类
  - messenger也是用的binder机制，只不过比aidl更方便